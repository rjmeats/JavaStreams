package streams;

import java.util.function.UnaryOperator;
import java.util.function.Supplier;
import java.util.function.IntSupplier;
import java.util.stream.Stream;
import java.util.stream.IntStream;
import java.math.BigDecimal;
import java.math.BigInteger;		// https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html
import java.math.RoundingMode;

public class Series {

	public static void main(String argv[]) {

		int howMany = 30;
		int seed = 1;
		
		System.out.println("Fibonacci series:");
		Stream<Integer> s = Stream.iterate(seed, new FibonacciSeries());			// seed value is applied to stream as first item, before apply has ever been called. 		
		s.limit(howMany).forEachOrdered(System.out::println);

		System.out.println();		
		System.out.println("Fibonacci series 2:");
		FibonacciSeries2.FibonacciNumber seed2 = new FibonacciSeries2.FibonacciNumber(1, 1, 0);
		Stream<FibonacciSeries2.FibonacciNumber> s2 = Stream.iterate(seed2, new FibonacciSeries2()); 		
		s2.limit(howMany).forEachOrdered(System.out::println);

		System.out.println();
		System.out.println("Approximation to e:");
		howMany = 20;
		double seed3 = 0.0;
		Stream<Double> s3 = Stream.iterate(seed3, new ApproxE());			// seed value is applied to stream as first item, before apply has ever been called. 		
		s3.limit(howMany).forEachOrdered(System.out::println);
		
		System.out.println();
		System.out.println("Approximation to e using BigDecimal:");
		howMany = 50;
		BigDecimal seed4 = BigDecimal.ZERO;
		Stream<BigDecimal> s4 = Stream.iterate(seed4, new BDApproxE());			// seed value is applied to stream as first item, before apply has ever been called. 		
		s4.limit(howMany).forEachOrdered(System.out::println);

		// Stream consisting of powers of two using the iterate method
		System.out.println();
		System.out.println("Powers of 2:");
		howMany = 10;
		IntStream is = IntStream.iterate(1, n -> (n*2)); 		
		is.limit(howMany).forEachOrdered(System.out::println);
		
		// Infinite stream of Factorials (overflows before long, not really infinite) 
		System.out.println();
		System.out.println("Factorials:");
		howMany = 10;
		IntStream is2 = IntStream.generate(new FactorialSeries()); 		
		is2.limit(howMany).forEachOrdered(System.out::println);		

		// Infinite stream of Factorials using BigInteger 
		System.out.println();
		System.out.println("Factorials using BigInteger:");
		howMany = 100;
		Stream<BigInteger> bis = Stream.generate(new BigFactorialSeries());	
		bis.limit(howMany).forEachOrdered(System.out::println);		

		// Infinite stream of words from a sentence (empty strings before long, as sentence is finite.)
		System.out.println();
		System.out.println("Words from a sentence:");
		howMany = 20;
		Stream<String> s5 = Stream.generate(new StringWord("Returns an infinite sequential unordered stream where each element is generated by the providedÂ Supplier")); 		
		s5.limit(howMany).forEachOrdered(System.out::println);		

		// Infinite stream of random numbers
		System.out.println();
		System.out.println("Random numbers:");
		howMany = 10;
		Stream<Double> randomNumbers = Stream.generate(Math::random);
		randomNumbers.limit(howMany).forEachOrdered(System.out::println);
		//	System.out.println("Generated " + randomNumbers.count() + " random numbers");		// NB This never returns - it's an inifinite stream
	}
}

class FibonacciSeries implements UnaryOperator<Integer> {
	
	int m_previous;
	int m_count;
	
	FibonacciSeries() {
		m_previous = 0;
		m_count = 0;
	}
	
	public Integer apply(Integer seed) {
		m_count++;
		int latest = (seed == 0) ? 1 : m_previous + seed;		
		m_previous = seed;
//		System.out.println("In apply : count=" + m_count + ", seed=" + seed + ", return= " + latest);		
		return latest;
	}
	
}

class FibonacciSeries2 implements UnaryOperator<FibonacciSeries2.FibonacciNumber>  {
	int m_previous;
	int m_count;
	
	FibonacciSeries2() {
		m_previous = 0;
		m_count = 0;
	}
	
	static class FibonacciNumber {
		int m_index;
		int m_value;
		int m_previous;
		
		FibonacciNumber(int index, int value, int previous) {
			m_index = index;
			m_value = value;
			m_previous = previous;
		}
		
		public String toString() {
			double ratio = m_previous == 0 ? 0 : 1.0 * m_value / m_previous;
			return m_index + " : " + m_value + " (" + m_previous + ") + ratio: " + (m_previous != 0 ? ("" + ratio) : "-");
		}
	}

	public FibonacciNumber apply(FibonacciNumber seed) {
		m_count++;
		int index = seed.m_index+1;
		int latest = (seed.m_value == 0) ? 1 : m_previous + seed.m_value;		
		m_previous = seed.m_value;
//		System.out.println("In apply : count=" + m_count + ", seed=" + seed + ", return= " + latest);		
		return new FibonacciNumber(index, latest, m_previous);
	}
}

/**
 * Approximations to the value of e (2.18281828 ...) produced using the formula:
 * 
 *   e = 2 + 1/2! + 1/3! + 1/4! + ...
 *   
 *   To 50 decimal places, e = 2.71828182845904523536028747135266249775724709369995 from https://en.wikipedia.org/wiki/E_(mathematical_constant)
 */
class ApproxE implements UnaryOperator<Double> {		
		
	long m_previousFactorial;
	int m_count;
	
	ApproxE() {
		m_previousFactorial = 0;
		m_count = 0;
	}
	
	public Double apply(Double seed) {
		m_count++;
		double latest = 0;
		if(m_count == 1) {
			latest = 2;
			m_previousFactorial = 1;
		}
		else {
			long nextFactorial = m_previousFactorial * m_count;
			latest = seed + (1.0/nextFactorial);
			m_previousFactorial = nextFactorial;
		}				
		return latest;
	}
}

// Try using BigDecimal instead of double to get lots more digits
// https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html

class BDApproxE implements UnaryOperator<BigDecimal> {		
	
	BigDecimal m_previousFactorial;
	int m_count;
	
	static int scale = 1000;
	
	BDApproxE() {
		m_previousFactorial = new BigDecimal(0);
		m_count = 0;
	}
	
	public BigDecimal apply(BigDecimal seed) {
		m_count++;
		BigDecimal latest = new BigDecimal(0);
		if(m_count == 1) {
			latest = new BigDecimal(2);
			m_previousFactorial = new BigDecimal(1);
		}
		else {
			BigDecimal nextFactorial = m_previousFactorial.multiply(new BigDecimal(m_count));
			BigDecimal reciprocal = BigDecimal.ONE.divide(nextFactorial, scale, RoundingMode.HALF_DOWN);
			// System.out.println("Reciprocal of " + nextFactorial + ": " + reciprocal.stripTrailingZeros());			
			latest = seed.add(reciprocal);
			m_previousFactorial = nextFactorial;
		}				
		return latest;
	}
}

// A couple of Supplier examples for use with Stream.generate. NB An infinite stream is generated, so these are not
// ideal examples .. Possibly need to use a spliterator to produce a true finite stream ?

class FactorialSeries implements IntSupplier {

	int m_previous;
	int m_factorialNumber;
	
	FactorialSeries() {
		m_previous = 1;
		m_factorialNumber = 0;
	}
	
	public int getAsInt() {
		m_factorialNumber++;
		int next= m_previous * m_factorialNumber;		// Overflows before long
		m_previous = next;
		return next;
	}
}

class BigFactorialSeries implements Supplier<BigInteger> {

	BigInteger m_previous;
	BigInteger m_factorialNumber;
	
	BigFactorialSeries() {
		m_previous = BigInteger.ONE;
		m_factorialNumber = BigInteger.ZERO;
	}
	
	public BigInteger get() {
		m_factorialNumber = m_factorialNumber.add(BigInteger.ONE);
		BigInteger next= m_previous.multiply(m_factorialNumber);
		m_previous = next;
		return next;
	}
}

class StringWord implements Supplier<String> {
	
	String m_source;
	String [] m_words;
	int m_count;
	
	StringWord(String source) {
		m_source = source;
		m_words = source.split("\\s+");
		m_count = 0;
	}
	
	public String get() {
		m_count++;
		if(m_count < m_words.length-1) {
			return m_words[m_count];
		}
		else {
			return ""; // Not really infinite!
		}
	}
}
